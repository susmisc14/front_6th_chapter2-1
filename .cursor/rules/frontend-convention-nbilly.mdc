---
alwaysApply: true
---
## 2. Custom Rules

### a. Follow the specified file naming conventions

- By default, the filename should match the `export default` member.
- **React Components**: Use **PascalCase**. (e.g., `App.tsx`)
- **Multiple Exports**: If a file has multiple exports, use **camelCase**. (e.g., `decorator.ts`)
- **Directories**: Use **kebab-case**. (e.g., `use-case`, `demo-renderer`)

### b. Functions must be named

Anonymous functions are not allowed. This helps with debugging and profiling.

> **Good ✅**
>
> ```javascript
> (function bar() {
>   // ...
> })();
> ```

> **Bad ❌**
>
> ```javascript
> (function () {
>   // ...
> })();
> ```

### c. Enum properties and values must be UPPER_SNAKE_CASE

> **Good ✅**
>
> ```typescript
> export enum EInterceptorType {
>   REQUEST_SUCCESS = "REQUEST_SUCCESS",
>   REQUEST_ERROR = "REQUEST_ERROR",
> }
> ```

> **Bad ❌**
>
> ```typescript
> export enum EInterceptorType {
>   requestSuccess = "requestSuccess",
>   requestError = "requestError",
> }
> ```

### d. `index` files are only for re-exporting modules

`index` files should only serve as an entry point for a module by re-exporting its members. Do not define any logic, imports, or variables within `index` files.

> **Good ✅**
>
> ```typescript
> export * from "./editor";
> export * from "./renderer";
> export * from "./shared";
> export * from "./viewer";
> ```

> **Bad ❌**
>
> ```typescript
> import axios, { AxiosError } from "axios";
>
> const ajaxFailure = (error: AxiosError, config: TAjaxRequestOption) => {
>   // ...logic
> };
> ```

### e. Do not use `as`, `any`, or `!`

The use of `as` (type casting), `any`, and the non-null assertion operator (`!`) is restricted via `tsconfig` and linting rules. If you must use them, leave a comment explaining the reason for the exception.

### f. Do not use verbs in boolean variable names

To strictly enforce the rule that verbs are used only for functions, do not prefix boolean variables with `is-`, `has-`, etc.

**Tip**: To name a boolean, think of a name with a "be" verb or auxiliary verb, and then remove it. For example, `isTransformUpdated` becomes `transformUpdated`. If naming is still difficult, consider creating a function instead.

### g. Use PascalCase for TypeScript types and interfaces

All `type` aliases and `interface` definitions should be written in **PascalCase**. Distinguish them with a `T-` prefix for `type` and an `I-` prefix for `interface`.

### h. Use `type` by default, `interface` only when necessary

We recommend using `type` aliases by default. Use `interface` only when you need features that `type` does not support, such as declaration merging or self-referencing generic constraints.

**Reasons for preferring `type`:**

- **Documentation**: `typedoc` requires comments on each property for an `interface`, but only a single comment on the declaration for a `type`.
- **Sufficiency**: `type` aliases can handle most use cases.
- **Consistency**: Using `type` as the default maintains code consistency.

> **Good ✅**
>
> ```typescript
> // Use type for general type definitions
> export type TButtonProps = {
>   text: string;
>   onClick: () => void;
> };
>
> // Use interface only for special cases like self-referencing generics
> export default interface IButtonBlock
>   extends TBlock<IButtonBlock>,
>   TRichTextable,
>   // ... other types
> {
>   type: typeof BUTTON_BLOCK_TYPE;
> }
> ```

### i. Use `handle-` for event handlers and `on-` for callback props

To avoid naming collisions and improve clarity, use distinct prefixes for event handler functions and callback props.

- **Callback Props**: Use the `on-` prefix, similar to native HTML element event props (e.g., `onClick`).
- **Event Handler Functions**: Use the `handle-` prefix.
- Match the handler to the prop name: `handleClick` should be assigned to `onClick`.

> **Good ✅**
>
> ```typescript
> type TProps = {
>   onClose: () => void;
> };
>
> export default function PublishModal({ open, onClose }: TProps) {
>   const handleClick = useCallback(async () => {
>     // ...
>     onClose();
>   }, [onClose]);
>
>   return <Button onClick={handleClick}>Publish</Button>;
> }
> ```

### j. Keep logic out of React components

> **Intent**: React components are excluded from test coverage because UI testing is complex and better suited for manual QA. Therefore, logic should be separated from presentation.

React components should be pure presentation components. Extract any business logic into custom Hooks or utility functions, and ensure those have dedicated test coverage.

### k. Reference event objects only within the event handler

> **Intent**: To prevent the event object's schema from leaking into other layers of the application, we decouple business logic from the event handler. This makes business logic more reusable and independent.

Pass only the necessary data from the event object to business logic functions, not the entire event object itself.

> **Good ✅**
>
> ```typescript
> // Event object is only used here
> const handleMoveStart = useCallback(
>   (dragStartEvent: DragStartEvent) => {
>     const draggingBlockIds = active.data.current?.location?.blockIds ?? [];
>     // Pass primitive data, not the event object
>     deselectNonDraggingBlocks(draggingBlockIds);
>   },
>   [deselectBlock, selectedBlockIds]
> );
>
> // Business logic is decoupled from the event object
> const deselectNonDraggingBlocks = useCallback(
>   (draggingBlockIds: TEntityId[]) => {
>     difference(selectedBlockIds, draggingBlockIds).forEach((blockId) => {
>       deselectBlock(blockId);
>     });
>   },
>   [deselectBlock, selectedBlockIds]
> );
> ```
>
> **Bad ❌**
>
> ```typescript
> // Don't pass the whole event object
> const handleMoveStart = useCallback(
>   (dragStartEvent: DragStartEvent) => {
>     deselectNonDraggingBlocks(dragStartEvent);
>   },
>   [deselectBlock, selectedBlockIds]
> );
>
> // Business logic now depends on the DragStartEvent type
> const deselectNonDraggingBlocks = useCallback(
>   ({ active }: DragStartEvent) => {
>     const draggingBlockIds = active.data.current?.location?.blockIds ?? [];
>     // ...
>   },
>   [deselectBlock, selectedBlockIds]
> );
> ```

---

## 3. Recommendations

### a. Encapsulate primitive hooks within custom hooks

It is recommended to wrap primitive React hooks (`useState`, `useEffect`, etc.) in your own custom hooks instead of using them directly in components.

The primary goal is **encapsulation**, not just code reuse. This approach helps manage complexity and keeps related logic co-located, making the code easier to maintain as requirements change.
